[{"path":"index.html","id":"introduction","chapter":"1 Introduction","heading":"1 Introduction","text":"tutorial aims show methods described two papers Simon S. Skene Michael G. Kenward1,2 (paper paper II) can applied R.papers, assumed data can represented multivariate Gaussian linear model. model following form:\\[\\begin{equation}\n  y_i \\sim N(X_i \\beta;\\Sigma_i ), \\quad =1, \\dots,n\n  \\tag{1.1}\n\\end{equation}\\]\\(y_i\\) \\((T_i \\times 1)\\) response vector, \\(X_i\\) \\((T_i \\times p)\\) design matrix \\(\\Sigma_i\\) \\((T_i \\times T_i)\\) covariance matrix \\(\\)th subject \\(n\\) subjects.Papers II cover various methods can used analysis repeated measurements framework, quick overview methods.","code":""},{"path":"index.html","id":"methods-we-will-focus-on","chapter":"1 Introduction","heading":"1.1 Methods we will focus on:","text":"","code":""},{"path":"index.html","id":"Overview-Adjusted-Sandwich-Estimator","chapter":"1 Introduction","heading":"1.1.1 Adjusted Sandwich Estimator","text":"sandwich estimator, shown paper , avoids estimate \\(\\Sigma\\) calculation estimate \\(\\beta\\). uses empirical estimate \\(\\Sigma\\) give estimate variance \\(\\hat\\beta\\).However, tests based statistics using estimator unreliable. Section 3 paper \\(F\\)-test using Wald statistic takes account variability sandwich estimator shown.","code":""},{"path":"index.html","id":"Overview-Modified-Box-Correction","chapter":"1 Introduction","heading":"1.1.2 Modified Box Correction","text":"Box correction correction one way ANOVA \\(F\\)-statistic follows \\(F\\) distribution assumptions independent equally variable Gaussian errors. Therefore depart general model given (1.1) assume \\(\\Sigma = \\text{diag}(\\sigma^2)\\).Box correction \\(\\psi^{-1}\\)\\(F\\) follows \\(F\\) distribution general model, Gaussian errors longer restricted independent equally variable.modified Box correction ratio quadratic forms treated scaled \\(F\\)-statistic instead ratio independent chi-squared distributions. modified Box correction preferred Box’s original statistic conservative hence less powerful.order compute modified Box correction require consistent estimator covariance matrix \\(\\Sigma\\). many options , example, use OLS covariance estimate. However, software fit mixed models REML estimator covariance matrix computed therefore often practical use estimate. ideal case compute unstructured REML estimate, possible can compute estimate \\(\\Sigma\\) complex structure data support.addition, also possible use empirical estimator sample covariance matrix, example shown Section 6.2 paper II. recreate results example R subection 4.2.3.","code":""},{"path":"index.html","id":"Overview-Scheffe-contrast","chapter":"1 Introduction","heading":"1.1.3 Scheffé contrast","text":"Alongside modified Box correction test significance covariates response variable, paper II also covers Scheffé’s method can adapted use modified Box corrected statistic.Scheffé’s method can used test possible contrasts means, paper II Scheffé’s method used give confidence intervals individual contrasts guinea pig papillary muscle example (see Section 6.2 paper II). recreate results example R Section 5.","code":""},{"path":"index.html","id":"SAS-Intro","chapter":"1 Introduction","heading":"1.2 SAS","text":"analysis two papers carried using SAS. particular, procedure PROC MIXED used calculate estimator covariance matrix modified Box correction. SAS provides documentation PROC MIXED, penultimate paragraph within overview section describes SAS procedure fits structure select data using method restricted maximum likelihood (REML).tutorial focus providing functions R compute methods described papers, present SAS code used Simon Skene calculate results example 6.1 paper II.","code":""},{"path":"index.html","id":"R-Intro","chapter":"1 Introduction","heading":"1.3 R","text":"three methods listed (Sandwich Estimator, Modified Box Correction Scheffé contrasts) provide R functions compute . modified Box correction requires estimate \\(\\Sigma\\) paper II REML estimate used. order compute estimate utilise R packages fit mixed models.multiple packages fit mixed models R, popular nlme lme4 packages. packages use REML default fit mixed model, therefore can use extract estimate covariance matrix compute modified Box correction.differences two packages described page 4 lme4 package documentation. main difference nlme package allows flexibility choosing complex variance-covariance structures. hand, lme4 package allows us induce correlation structure individuals including random effects model.","code":""},{"path":"Modified-Box-Correction-SAS.html","id":"Modified-Box-Correction-SAS","chapter":"2 Modified Box Correction","heading":"2 Modified Box Correction","text":"","code":""},{"path":"Modified-Box-Correction-SAS.html","id":"example","chapter":"2 Modified Box Correction","heading":"2.1 Example","text":"","code":""},{"path":"Modified-Box-Correction-SAS.html","id":"cardiac-enzyme","chapter":"2 Modified Box Correction","heading":"2.1.1 Cardiac enzyme","text":"show calculate modified Box corrected \\(F\\)-statistic SAS, present code used Simon Skene calculate results example 6.1 paper II.reproduce examples paper need import datasets used. Alongside tutorial GitHub repository contains folder datasets used paper can easily downloaded.SAS can import Cardiac Enzyme dataset directly GitHub repository running code:Next need create mixed model. example random effects therefore include random statement, however unstructured covariance matrix can define using repeated statement.","code":"filename cardiac url \"https://raw.githubusercontent.com/DylanDijk/Simon-Skene-Mixed-Models-Tutorial/main/Data_Images_Figures/The%20Cardiac%20Enzyme%20Data%20-%20Reduced%20Data%20set.csv\";\n\nproc import file=cardiac out=cardiac_data dbms=csv;\nrun;proc mixed data=cardiac_data;\nclass dog trt time;\nmodel atp=trt time trt*time/ ddfm=kr s;\nrepeated time/type=un subject=dog r=4;\nrun;title2 \"Inference Using Box Corrections\";\n\nproc iml;\n\nm=12; /* number of subjects */\np=9;  /* number of time points */\n\n\nuse d var{atp};\nread all;\n\ny=atp;\n\nuse rmat var{col1 col2 col3 col4 col5 col6 col7 col8 col9};\nread all;\nrmat=col1||col2||col3||col4||col5||col6||col7||col8||col9;\n\nSIGMA=rmat;\n\n\nic=j(m*p,1,1);\n\ntrt1=j(m*p/2,1,0)//j(m*p/2,1,1);\ntrt2=j(m*p/2,1,1)//j(m*p/2,1,0);\ntrt=trt2;\n\ntime=i(p);\ndo i=2 to m by 1;\n    time=time//i(p);\n    end;\ntime=time[,2:9];\n\nint=j(m*p,(p-1),.);\ndo i=1 to (p-1);\n   int[,i]=time[,i]#trt;\n   end;\n\nX=ic||trt||time||int;\nXr=ic||trt||time;\n\nparm=ncol(X);c=ncol(X)-ncol(Xr);\n\n\ntot=m*p;\nind=j(tot,1,1);\ndo i=1 to tot by 1;\n    if  y[i]=. then ind[i]=0;\nend;\nnobs=sum(ind);\n\nmobs=j(m,1,.);\ndo i=1 to m by 1;\n    mobs[i]=sum(ind[(i-1)*p+1:(i*p)]);\nend;\n\ncnt=j(m,1,.);\ndo i=1 to m by 1;\n    cnt[i]=sum(mobs[1:i]);\nend;\n\nyrem=y[loc(ind=1)];\nXrem=X[loc(ind=1),];\nXr_rem=Xr[loc(ind=1),];\n\n\nstart block_V(Mat) global(m);\n    ans=i(m)@Mat;\n    return(ans);\nfinish block_V;\n\nstart block_Vrem(Mat) global(m,p,cnt,mobs,nobs);\n    ans=j(nobs,nobs,0);\n    do i=1 to m by 1;\n        if mobs[i]=p then Mati=Mat;\n        else Mati=Mat[1:mobs[i],1:mobs[i]];\n        if i=1 then ans[1:cnt[1],1:cnt[1]]=Mati;\n        else ans[cnt[i-1]+1:cnt[i],cnt[i-1]+1:cnt[i]]=Mati;\n    end;\n    return(ans);\nfinish block_Vrem;\n\nVrem=block_Vrem(SIGMA);\n\n/* ANOVA F-test*/\n\nA=i(nobs)-Xrem*inv(t(Xrem)*Xrem)*t(Xrem);\nB=Xrem*inv(t(Xrem)*Xrem)*t(Xrem)-Xr_rem*inv(t(Xr_rem)*Xr_rem)*t(Xr_rem);\nF=(nobs-parm)#(t(yrem)*B*yrem)/(c#t(yrem)*A*yrem);\n\nnumdf=c;dendf=nobs-parm;\n\n/* Box Correction */\n\npsi=(nobs-parm)#trace(B*Vrem)/(c#trace(A*Vrem));\nv1_BOX=((trace(B*Vrem))##2)/trace(B*Vrem*B*Vrem);\nv2_BOX=((trace(A*Vrem))##2)/trace(A*Vrem*A*Vrem);\n\nF_BOX=F/psi;\n\n/* Modified Box Correction */\n\nE=trace(B*Vrem)/trace(A*Vrem);\nV=(trace(B*Vrem*B*Vrem)/((trace(B*Vrem))##2))+(trace(A*Vrem*A*Vrem)/((trace(A*Vrem))##2));\nv1_MOD=c;\nv2_MOD=(c#(4#V+1)-2)/(c#V-1);\nlambda=((nobs-parm)/c)#((v2_MOD-2)/v2_MOD)#E;\n*lambda=((nobs-parm)/c)#((v2-2)/v2)#E;\n\nF_MOD=F/lambda;\n\nprob_F=1-cdf(\"F\",F,numdf,dendf);\nprob_F_BOX=1-cdf(\"F\",F_BOX,v1_BOX,v2_BOX);\nprob_F_MOD=1-cdf(\"F\",F_MOD,v1_MOD,v2_MOD);\n\n/* Printing of results */\n\nprint / \"ANOVA F Statistic\";\nprint F numdf dendf prob_F;\n\nprint \"Box Correction\";\nprint psi F_BOX v1_BOX v2_BOX prob_F_BOX;\n\nprint \"Modified Box Correction\";\nprint lambda F_MOD v1_mod v2_mod prob_F_MOD;"},{"path":"Sandwich-Estimator.html","id":"Sandwich-Estimator","chapter":"3 Sandwich Estimator","heading":"3 Sandwich Estimator","text":"","code":""},{"path":"Sandwich-Estimator.html","id":"sandwich-estimator---r-function","chapter":"3 Sandwich Estimator","heading":"3.1 Sandwich Estimator - R Function","text":"code gives R function returns estimate \\(\\beta\\) using GEE approach (denoted \\(\\hat\\beta_W\\) paper ) setup multivariate linear model described equation (1.1). function also returns sandwich estimator covariance matrix estimate \\(\\beta\\).use function need copy code (can click clipboard symbol top right corner code chunk) run R R environment. use function illustrated example.sandwich_estimator() function takes four inputs: model, subjects, data W. model used describe mean model takes form give formula lm(). subjects variable used identify variable data labels subjects. W used set working covariance matrix. paper II working covariance matrix denoted (\\(W^{-1}\\)).","code":"\nlibrary(Matrix)\n\nsandwich_estimator = function(model, subjects, data, W = NA){\n  \n  model_formula = as.formula(model)\n  \n  X = model.matrix(model_formula, data = data)\n  full_model_frame = model.frame(model_formula, data = data)\n  Y = model.response(full_model_frame)\n  \nif(is.na(W)){\n  W = diag(1, nrow = nrow(X))\n}\n  \nbeta_W = solve(t(X)%*%solve(W)%*%X)%*%t(X)%*%solve(W)%*%Y\n  \n  \n  sigma_i_comb = list()\n  for(i in levels(data[[paste(subjects)]])){\n    \n    Y_i = Y[data[[subjects]] == i]\n    X_i = X[data[[subjects]] == i,]\n    sigma_i = (Y_i - (X_i %*% beta_W))\n    sigma_i = sigma_i[,1]\n    sigma_i = sigma_i %*% t(sigma_i)\n    \n    sigma_i_comb[[paste(i)]] = sigma_i\n  }\n  \n  sigma = bdiag(sigma_i_comb)\n  V_s = solve(t(X)%*%solve(W)%*%X)%*%t(X)%*%solve(W)%*%sigma%*%t(solve(t(X)%*%solve(W)%*%X)%*%t(X)%*%solve(W))\n  \n  return(list(\"beta_W\" = beta_W, \"V_s\" = V_s, \"sigma_i_comb\" = sigma_i_comb))\n  \n}"},{"path":"Sandwich-Estimator.html","id":"wald-test-using-sandwich-estimator---r-function","chapter":"3 Sandwich Estimator","heading":"3.2 Wald Test using Sandwich Estimator - R Function","text":"sandwich_estimator_p_value() function carries Wald test using sandwich estimate outputted sandwich_estimator() function, therefore functions need R environment.function additional model_r variable, assign formula variables removed want test significance full model defined model variable.","code":"\nsandwich_estimator_p_value = function(model, model_r, subjects, data, W = NA){\n  \n  sand_estimate = sandwich_estimator(model = model, subjects = subjects, data = data, W = W)\n\n  Beta_r_names =\n    colnames(model.matrix(model, data = data))[!(colnames(model.matrix(model, data = data)) %in%\n  colnames(model.matrix(model_r, data = data)))]\n\n  Beta_r = sand_estimate$beta_W[Beta_r_names,]\n  \n  Wald_sand_stat = (Beta_r %*% solve(sand_estimate$V_s[Beta_r_names,Beta_r_names]) %*% t(t(Beta_r)))[1]\n  Wald_sand_stat_p_value = pchisq(q = Wald_sand_stat, df = length(Beta_r), lower.tail = FALSE)\n  \nreturn(list(\"Wald_sand_stat\" = Wald_sand_stat, \"Wald_sand_stat_p_value\" = Wald_sand_stat_p_value, \"Beta_r\" = Beta_r))\n  \n}"},{"path":"Sandwich-Estimator.html","id":"Sandwich-Cardiac-Enzyme-Example","chapter":"3 Sandwich Estimator","heading":"3.2.1 Example - Cardiac Enzyme Dataset","text":"example look dataset mean model used example covered Section 6.1 paper II. apply sandwich_estimator() function output sandwich estimator covariance matrix estimated fixed effects. use sandwich_estimator_p_value() test inclusion interaction term treatment time model.First need import dataset. code imports dataset GitHub repository, converts selection variables dataset factors.code runs sandwich_estimator function:running function can extract estimate \\(\\beta\\) (beta_W) sandwich estimate \\(\\Sigma\\) (V_s).code runs sandwich_estimator_p_value() function:get following p-value:","code":"\nCardiac_enzyme_data = read.csv(\"https://raw.githubusercontent.com/DylanDijk/Simon-Skene-Mixed-Models-Tutorial/main/Data_Images_Figures/The%20Cardiac%20Enzyme%20Data%20-%20Reduced%20Data%20set.csv\")\nCardiac_enzyme_data$dog = as.factor(Cardiac_enzyme_data$dog)\nCardiac_enzyme_data$trt = as.factor(Cardiac_enzyme_data$trt)\nCardiac_enzyme_data$time = as.factor(Cardiac_enzyme_data$time)\nCardiac_enzyme_sandwich_estimate = \n  sandwich_estimator(model = atp ~  trt + time + trt:time,\n                     subjects = \"dog\", data = Cardiac_enzyme_data)\nCardiac_enzyme_sandwich_estimate$beta_W\nCardiac_enzyme_sandwich_estimate$V_s\nCardiac_enzyme_sandwich_wald_p_value = \nsandwich_estimator_p_value(model = atp ~ trt + time + trt:time,\n                           model_r = atp ~ trt + time, \n                           data = Cardiac_enzyme_data, subjects = \"dog\")Cardiac_enzyme_sandwich_wald_p_value$Wald_sand_stat_p_value\n[1] 1.02213e-55"},{"path":"Sandwich-Estimator.html","id":"adjusted-sandwich-estimator","chapter":"3 Sandwich Estimator","heading":"3.3 Adjusted Sandwich Estimator","text":"adj_sandwich_estimator() function computes Wald \\(F\\)-statistic described Section 3 paper . function uses sandwich estimator computed sandwich_estimator() function therefore requires previous functions R environment.function input variables adj_sandwich_estimator_p_value() function.","code":"\nadj_sandwich_estimator = function(model, model_r, subjects, data, W = NA){\n  \n  sand_estimate = sandwich_estimator(model = model, subjects = subjects, data = data)\n  \n  sand_stat = sandwich_estimator_p_value(model = model, model_r = model_r, subjects = subjects, data = data)\n  \n  l = length(sand_stat$Beta_r)\n\nK = list(length = l^2)\n\nfor(i in 1:l^2){\n  \n          vec = rep(0, l^2)\n\n  if(((i - 1) %% (l + 1)) == 0){\n    \n      for(j in 1:l^2){\n      \n        if(((j - 1)) %% (l + 1) == 0){\n          vec[j] = 1\n          \n        }\n      }  \n    }\n\n     K[[i]] =  vec     \n          \n}\n\nBeta_r_names = names(sand_stat$Beta_r)\n\nK = do.call(rbind, K)\nomega_hat = (diag(l^2) + K) %*% \n  (sand_estimate$V_s[Beta_r_names, Beta_r_names] %x%\n    sand_estimate$V_s[Beta_r_names, Beta_r_names]\n  )\n\nX = model.matrix(model, data = data)\n\nif(is.na(W)){\nW = diag(1, nrow = nrow(X))\n}\n\nmod_based_est = solve(t(X) %*% solve(W) %*% X)\n\nP_i = list()\n for(i in levels(data[[subjects]])){\n    \n    X_i = X[data[[subjects]] == i,]\n    P_i[[i]] =\n      c(\n    t(X_i) %*% W[data[[subjects]] == i,data[[subjects]] == i] %*% sand_estimate$sigma_i_comb[[i]] %*%\n    W[data[[subjects]] == i,data[[subjects]] == i] %*% X_i\n      )\n  }\n\nn = nrow(data)\n\nP_hat = Reduce(\"+\", P_i)/n\n\nP_i_minus_P_hat = lapply(P_i, function(x){x - P_hat})\n\nT_hat = Reduce(\"+\",lapply(P_i_minus_P_hat, function(x){x %*% t(x)}))/(n*(n-1))\n\npsi_hat = n^2 * (mod_based_est[Beta_r_names,] %x% mod_based_est[Beta_r_names,]) %*%\n             T_hat %*% t(mod_based_est[Beta_r_names,] %x% mod_based_est[Beta_r_names,])\n\nv = sum(diag(psi_hat %*% omega_hat))/sum(diag(psi_hat %*% psi_hat))\n\nF_Wald_adj_sand = (v - l + l)/(v * l) * sand_stat$Wald_sand_stat\n  \nF_Wald_adj_sand_p = pf(df1 = l, df2 = v - l +1, q = F_Wald_adj_sand, lower.tail = FALSE)\n\nreturn(list(\"F_Wald_adj_sand\" = F_Wald_adj_sand,\n            \"F_Wald_adj_sand_p\" = F_Wald_adj_sand_p))\n\n}"},{"path":"Sandwich-Estimator.html","id":"example-1","chapter":"3 Sandwich Estimator","heading":"3.3.1 Example","text":"example analogue calculation p-value subsection 3.2.1.get following Wald \\(F\\)-statistic p-value:","code":"\nCardiac_enzyme_adj_sandwich_wald_p_value = \nadj_sandwich_estimator(model = atp ~ trt + time + trt:time,\n                           model_r = atp ~ trt + time, \n                           data = Cardiac_enzyme_data, subjects = \"dog\")Cardiac_enzyme_adj_sandwich_wald_p_value$F_Wald_adj_sand\n[1] 34.91697\nCardiac_enzyme_adj_sandwich_wald_p_value$F_Wald_adj_sand_p\n[1] 0.1325053"},{"path":"Modified-Box-Correction.html","id":"Modified-Box-Correction","chapter":"4 Modified Box Correction","heading":"4 Modified Box Correction","text":"","code":""},{"path":"Modified-Box-Correction.html","id":"nlme","chapter":"4 Modified Box Correction","heading":"4.1 nlme","text":"code gives R function returns modified Box correction corresponding p-value. function uses mixed model objects nlme package define mean model, structure covariance matrix used. preferred choice use unstructured estimate, possible can compute estimate \\(\\Sigma\\) complex structure data support.function requires two nlme models input, model_r variable formula variables removed want test significance full model defined model variable.default estimate \\(\\Sigma\\) REML estimate extracted model object defined model input variable. However, want use alternative covariance estimate can select using Sigma variable. example Section 4.2.3 use sample covariance matrix.R session copy run code available R environment. Next give examples applying function recreate results presented paper II.","code":"\nlibrary(nlme)\n\nBox_correction_modified_nlme = function(model, model_r, data, Sigma = NULL){\n  \n  rownames(data) = c()\n  # Design matrix for full model\n  X <- model.matrix(model,data = data)\n  \n  # Gives the rownumbers of the dataset that have missing values\n  ind = which(is.na(match(rownames(data),rownames(X))))\n  \n  Y = getResponse(model)\n  \n  # Design matrix for model with removed variables\n  X_r <- model.matrix(model_r,data = data)\n  # Number of observations\n  n = nrow(X)\n  # Number of variables\n  parm = ncol(X)\n  # Number of variables being removed\n  c = ncol(X)-ncol(X_r)\n  \n  if(is.null(Sigma)){\n    \n    # Put in if statement to deal with models with no correlated errors\n    if(is.null(model$modelStruct$corStruct)){\n      \n      Sigma = diag((model$sigma)^2, nrow = n, ncol = n)\n      \n    } else {\n      # repeats = as.numeric(levels(model$groups))\n      \n      # Creating block matrix for model with correlated errors\n      # type = \"marginal\" extracts the covariance matrix when \n      # not conditioning on the random effects. Therefore extracts \n      # the full covariance matrix G side and R side.\n      Sigma = getVarCov(model, type = \"marginal\")\n      Sigma = diag(nlevels(model$groups)) %x% Sigma\n      if(!(length(ind) == 0)){\n        Sigma = Sigma[-ind,-ind]\n      }\n    }\n    \n  }\n  \n  A = diag(n) - ( X %*% solve( t(X) %*% X ) %*% t(X) )\n  B = ( X %*% solve( t(X) %*% X ) %*% t(X) )  -  ( X_r %*% solve( t(X_r) %*% X_r ) %*% t(X_r) ) \n  \n  trace = function(x){\n    sum(diag(x))\n  }\n  \n  V = ( (trace((B %*% Sigma) %*% (B %*% Sigma)) / trace(B %*% Sigma)^2)\n        + (trace((A %*% Sigma) %*% (A %*% Sigma)) / trace(A %*% Sigma)^2) )   \n  \n  \n  v_2 = (c*(4*V + 1) - 2)/((c*V) - 1)\n  \n  lambda = ((n - parm)/c) * ((v_2 - 2)/v_2) * ((trace(B %*% Sigma) / trace(A %*% Sigma)))\n  \n  F_ =  ((n - parm)/c) * ((t(Y) %*% B %*% Y)/(t(Y) %*% A %*% Y))\n  \n  F_mod = F_/lambda\n  \n  p_value = pf(df1 = c, df2 = v_2, q =  F_mod, lower.tail = F)\n  \n  values = c(lambda, F_, c, v_2, F_mod, p_value)\n  names(values) = c(\"Lambda\", \"F_\", \"v1_MOD\", \"v2_mod\",\"F_MOD\", \"prob_F_mod\")\n  values = round(values, digits = 3)\n  \n  \n  fixed_effects_estimate = solve(t(X)%*%X)%*%t(X)%*%Y\n  \n  return(list(\"Lambda\" = lambda, \"F_\" = F_[1], \"c\" = c, \"v2_mod\" = v_2, \"F_MOD\" = F_mod[1],       \n              \"prob_F_mod\" = p_value[1], \"A\" = A, \"B\" = B, \"n\" = n, \"r\" = parm, \"Y\" = Y,\n              \"fixed_effects_estimate\" = fixed_effects_estimate))\n  \n}"},{"path":"Modified-Box-Correction.html","id":"examples","chapter":"4 Modified Box Correction","heading":"4.2 Examples","text":"","code":""},{"path":"Modified-Box-Correction.html","id":"cardiac-enzyme-1","chapter":"4 Modified Box Correction","heading":"4.2.1 Cardiac enzyme","text":"example look dataset mean model used example covered Section 6.1 paper II. apply Box_correction_modified_nlme() function test inclusion interaction term treatment time model.apply function original dataset dataset artificial dropouts, recreate results Table VII.First need import dataset. code imports dataset GitHub repository, converts selection variables dataset factors.code creates nlme models, good resource documenting fit different mixed models nlme Fitting linear mixed models R Brice Ozenne.also set glsControl(tolerance = 10^-8), match convergence criteria used nlme default convergence criteria used PROC MIXED SAS.\n\ncan compare results Box_correction_modified_nlme() function results given upper panel Table VII paper II.","code":"\nCardiac_enzyme_data = read.csv(\"https://raw.githubusercontent.com/DylanDijk/Simon-Skene-Mixed-Models-Tutorial/main/Data_Images_Figures/The%20Cardiac%20Enzyme%20Data%20-%20Reduced%20Data%20set.csv\")\nCardiac_enzyme_data$dog = as.factor(Cardiac_enzyme_data$dog)\nCardiac_enzyme_data$trt = as.factor(Cardiac_enzyme_data$trt)\nCardiac_enzyme_data$time = as.factor(Cardiac_enzyme_data$time)\nlibrary(nlme)\nglsControl(tolerance = 10^-8)\n\nmodel = gls(model = atp ~  trt + time + trt:time,\n            data = Cardiac_enzyme_data,\n            correlation = corSymm(form =~ as.numeric(time)|dog),\n            weights = varIdent(form =~ 1|time))\n\n\nmodel_r = gls(model = atp ~ trt + time,\n              data = Cardiac_enzyme_data,\n              correlation = corSymm(form =~ as.numeric(time)|dog),\n              weights = varIdent(form =~ 1|time))\ncardiac_mod_box = \nBox_correction_modified_nlme(data = Cardiac_enzyme_data, model = model, model_r = model_r)cardiac_mod_box$F_MOD\n[1] 2.520353\ncardiac_mod_box$prob_F_mod\n[1] 0.07743055"},{"path":"Modified-Box-Correction.html","id":"cardiac-enzyme---artifical-missing-data","chapter":"4 Modified Box Correction","heading":"4.2.2 Cardiac enzyme - Artifical missing data","text":"results lower panel Table VII computed applying method dataset now artificial missing data introduced. Box_correction_modified_nlme() function works missing data, run modified dataset code .first introduce missing data points Cardiac_enzyme_data dataset:code creates models modified dataset, identical model construction previous example new dataset.get resuls final row Table VII paper II:","code":"\nCardiac_enzyme_data_miss = Cardiac_enzyme_data\nCardiac_enzyme_data_miss$atp[which(Cardiac_enzyme_data_miss$dog == 4)][7:9] = NA\nlibrary(nlme)\nglsControl(tolerance = 10^-8)\n\n\nmodel = gls(model = atp ~  trt + time + trt:time,\n            data = Cardiac_enzyme_data_miss,\n            correlation = corSymm(form =~ as.numeric(time)|dog),\n            weights = varIdent(form =~ 1|time), na.action = na.omit)\n\nmodel_r = gls(model = atp ~ trt + time,\n              data = Cardiac_enzyme_data_miss,\n              correlation = corSymm(form =~ as.numeric(time)|dog),\n              weights = varIdent(form =~ 1|time), na.action = na.omit)\ncardiac_miss_mod_box = \nBox_correction_modified_nlme(model = model, model_r = model_r, data = Cardiac_enzyme_data_miss)cardiac_miss_mod_box$F_MOD\n[1] 2.84006\ncardiac_miss_mod_box$prob_F_mod\n[1] 0.05912901"},{"path":"Modified-Box-Correction.html","id":"Guinea-pigs","chapter":"4 Modified Box Correction","heading":"4.2.3 Guinea pigs","text":"example use dataset shows amplitude action potential measured pieces heart dissected guinea pigs. measurements taken exposed two different compounds, therefore two response variables AP1 AP2.piece tissue control measure compound given six increasing concentrations compound. carried three guinea pigs’ hearts, seven repeated measurements just three participants.code imports dataset converts concentration variable (conc.f) subject variable (gpig.f) factors:example experiments treated simple repeated measures designs concentration time variable tissue subject.Due small number samples, estimation method unstructured covariance models converge. Therefore, example Skene Kenward used sample covariance matrix estimator covariance matrix (\\(\\Sigma\\)).code computes sample covariance estimates seven repeated measurements, used inputs Sigma Box_correction_modified_nlme() function.Next create blocked version covariance matrices, block subjects. create covariance matrix need know number unique subjects dataset.Next construct models, make model response variables concentration (conc.f) covariate.run Box_correction_modified_nlme() function, using model objects created inputs.compound 1.gives following output:compound 2.compound 2, get values:","code":"\nGuinea_pigs_data = read.csv(\"https://raw.githubusercontent.com/DylanDijk/Simon-Skene-Mixed-Models-Tutorial/main/Data_Images_Figures/brammer.csv\")\n\nGuinea_pigs_data$conc.f = factor(Guinea_pigs_data$conc.f)\nGuinea_pigs_data$gpig.f = factor(Guinea_pigs_data$gpig.f)\nsigma_compound_1 = cov(rbind(Guinea_pigs_data[1:7,\"AP1\"],Guinea_pigs_data[8:14,\"AP1\"],Guinea_pigs_data[15:21,\"AP1\"]))\nsigma_compound_2 = cov(rbind(Guinea_pigs_data[1:7,\"AP2\"],Guinea_pigs_data[8:14,\"AP2\"],Guinea_pigs_data[15:21,\"AP2\"]))\nnumber_of_subjects = nlevels(Guinea_pigs_data$gpig.f) #number of subjects\n \nsigma_compound_1_block = diag(number_of_subjects) %x% sigma_compound_1\nsigma_compound_2_block = diag(number_of_subjects) %x% sigma_compound_2\nlibrary(nlme)\n\nmodel_AP1 = gls(AP1~conc.f,data=Guinea_pigs_data)\nmodel_AP1_r = gls(AP1~1,data=Guinea_pigs_data)\n\nmodel_AP2 = gls(AP2~conc.f,data=Guinea_pigs_data)\nmodel_AP2_r = gls(AP2~1,data=Guinea_pigs_data)\nBox_mod_1 =\nBox_correction_modified_nlme(model = model_AP1, model_r = model_AP1_r, data = Guinea_pigs_data, Sigma = sigma_compound_1_block)Box_mod_1$F_MOD\n[1] 4.497613\nBox_mod_1$prob_F_mod\n[1] 0.05698665\nBox_mod_2 = Box_correction_modified_nlme(model = model_AP2, model_r = model_AP2_r, data = Guinea_pigs_data, Sigma = sigma_compound_2_block)Box_mod_2$F_MOD\n[1] 20.84697\nBox_mod_2$prob_F_mod\n[1] 0.001995718"},{"path":"Scheffe-method.html","id":"Scheffe-method","chapter":"5 Scheffé’s method","heading":"5 Scheffé’s method","text":"","code":""},{"path":"Scheffe-method.html","id":"code","chapter":"5 Scheffé’s method","heading":"5.1 Code","text":"code gives R function uses Scheffé’s method modified Box corrected statistic calculate confidence intervals individual contrasts within categorical effect.\nuse Scheffe() function require Box_correction_modified_nlme() function R environment.Scheffe() function requires input variables model model_r, way used Box_correction_modified_nlme() function. However, looking contrasts within individual categorical variable model_r single categorical variable removed relative formula selected model. instance, example model_r categorical variable conc.f removed.function input variable used select contrasts want calculate confidence intervals . Equation (22) paper II shows \\(\\) vector used define contrasts.","code":"\nScheffe = function(model, model_r, data, Sigma = NULL, a, subjects){\n  \n  x = Box_correction_modified_nlme(model, model_r, data, Sigma)\n  \nC_a = sum((x$fixed_effects_estimate + (c(0,rep(x$fixed_effects_estimate[1],6)))) * a)\nsigma_2 = (t(x$Y) %*% x$A %*% x$Y)/(x$n-x$r)\n\ncat_var_removed = setdiff(attr(model$terms, \"term.labels\"), attr(model_r$terms, \"term.labels\"))\n\nn_i = vector()\nfor(i in 1:nlevels(data[[cat_var_removed]])){\n  n_i[i] = sum(!is.na(data[data[[cat_var_removed]] == levels(data[[cat_var_removed]])[i],cat_var_removed]))\n}\n\nS_Ca = sqrt(sigma_2 * sum(a^2/n_i))\nS_alpha_a = S_Ca * sqrt((x$c * x$Lambda) * qf(0.95,x$c,x$v2_mod))\n\nreturn(list(\"C_a\" = C_a, \"Conf_interval\" = paste0(\"(\",C_a - S_alpha_a,\", \", C_a + S_alpha_a, \")\")))\n  \n}"},{"path":"Scheffe-method.html","id":"Scheffe-Guinea-pig-example","chapter":"5 Scheffé’s method","heading":"5.2 Example","text":"already shown calculation modified box corrected statistic guinea pig example subsection 4.2.3. now extend calculate confidence intervals given Table X paper II.setup run Scheffe() function get confidence intervals identical setup subsection 4.2.3.choice contrasts want look based ordering levels categorical variable.\nTherefore want compute confidence interval mean difference control measure first concentration, set = c(-1,1,0,0,0,0,0).compound 1, get values:","code":"\nGuinea_pigs_data = read.csv(\"https://raw.githubusercontent.com/DylanDijk/Simon-Skene-Mixed-Models-Tutorial/main/Data_Images_Figures/brammer.csv\")\n\nGuinea_pigs_data$conc.f = factor(Guinea_pigs_data$conc.f)\nGuinea_pigs_data$gpig.f = factor(Guinea_pigs_data$gpig.f)\nlibrary(nlme)\n\nmodel_AP1 = gls(AP1~conc.f,data=Guinea_pigs_data)\nmodel_AP1_r = gls(AP1~1,data=Guinea_pigs_data)\n\nmodel_AP2 = gls(AP2~conc.f,data=Guinea_pigs_data)\nmodel_AP2_r = gls(AP2~1,data=Guinea_pigs_data)\nsigma_compound_1 = cov(rbind(Guinea_pigs_data[1:7,\"AP1\"],Guinea_pigs_data[8:14,\"AP1\"],Guinea_pigs_data[15:21,\"AP1\"]))\nsigma_compound_2 = cov(rbind(Guinea_pigs_data[1:7,\"AP2\"],Guinea_pigs_data[8:14,\"AP2\"],Guinea_pigs_data[15:21,\"AP2\"]))\nnumber_of_subjects = nlevels(Guinea_pigs_data$gpig.f) #number of subjects\n\nsigma_compound_1_block = diag(number_of_subjects) %x% sigma_compound_1\nsigma_compound_2_block = diag(number_of_subjects) %x% sigma_compound_2\nScheffe_comp_1 = \nScheffe(model = model_AP1, model_r = model_AP1_r, data = Guinea_pigs_data, Sigma = sigma_compound_1_block, a = c(-1,1,0,0,0,0,0), subjects = \"gpig.f\")Scheffe_comp_1$Conf_interval\n[1] \"(-3.07944941452269, 5.74611608118969)\""},{"path":"References.html","id":"References","chapter":"References","heading":"References","text":"","code":""}]
